"use strict";(self.webpackChunkthe_devs_nest=self.webpackChunkthe_devs_nest||[]).push([[180],{5149:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var i=t(5893),r=t(1151);const o={id:"sb-dependency-injection",sidebar_position:2,sidebar_label:"Dependency Injection",description:"",tags:["SpringBoot"]},s="SpringBoot Dependency Injection",a={id:"springBoot/sb-dependency-injection",title:"SpringBoot Dependency Injection",description:"",source:"@site/docs/springBoot/springBoot_dependencyInjection.md",sourceDirName:"springBoot",slug:"/springBoot/sb-dependency-injection",permalink:"/springBoot/sb-dependency-injection",draft:!1,unlisted:!1,tags:[{label:"SpringBoot",permalink:"/tags/spring-boot"}],version:"current",sidebarPosition:2,frontMatter:{id:"sb-dependency-injection",sidebar_position:2,sidebar_label:"Dependency Injection",description:"",tags:["SpringBoot"]},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/springBoot/sb-introduction"},next:{title:"Components",permalink:"/springBoot/sb-component"}},c={},l=[{value:"Inversion of Control (IoC)",id:"inversion-of-control-ioc",level:2},{value:"Dependency Injection",id:"dependency-injection",level:2},{value:"Introducing Beans",id:"introducing-beans",level:2},{value:"@Configuration",id:"configuration",level:3},{value:"@Bean",id:"bean",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"springboot-dependency-injection",children:"SpringBoot Dependency Injection"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Inversion of Control is a design principle that inverts the flow of control in a program by decoupling components, making them more flexible and easier to maintain."}),"\n",(0,i.jsx)(n.li,{children:"In a traditional approach, high-level components are in control of the flow and call low-level components."}),"\n",(0,i.jsx)(n.li,{children:"With IoC, this control is inverted, and low-level components are responsible for the flow, allowing high-level components to focus on their core functionalities."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"inversion-of-control-ioc",children:"Inversion of Control (IoC)"}),"\n",(0,i.jsx)(n.p,{children:"To understand dependency injection we need to get a little abstract :"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Let's say we were going to write a class and our class depends on three other classes in order to achieve its goal."}),"\n",(0,i.jsxs)(n.li,{children:["One way of handling these dependencies is that we can create them inside of our green class by using the Java ",(0,i.jsx)(n.code,{children:"new"})," keyword in a constructor"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"// Traditional way\npublic class ColorPrinter {\n  private RedPrinter redPrinter; // interface\n  private BluePrinter bluePrinter; // interface\n\n  public ColorPrinter() {\n    redPrinter = new EnglishRedPrinter();\n    bluePrinter = new EnglishBluePrinter();\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"If we needed to change these dependencies, swap them out, we'd actually need to change the code inside of the green class and we don't want to do that just to swap out and change a dependency."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"dependency-injection",children:"Dependency Injection"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Now let's say instead of creating those dependency classes inside of our class, we just declare the different interfaces that those classes meet."}),"\n",(0,i.jsxs)(n.li,{children:["In that case, something would need to provide the concrete classes that meets these implementations and we can have something sat around the outside of the class to do that, such as the ",(0,i.jsx)(n.strong,{children:"Spring Framework Container"})," and it will be up to the framework to create the concrete classes and then inject them where they are actually needed."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"// Dependency injection\npublic class ColorPrinter {\n  private RedPrinter redPrinter; // interface\n  private BluePrinter bluePrinter; // interface\n\n  public ColorPrinter(RedPrinter redPrinter, BluePrinter bluePrinter) {\n    this.redPrinter = redPrinter;\n    this.bluePrinter = bluePrinter;\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"In this way of doing things, if we needed to swap a dependency for a new class that implemented the same interface in a slightly different way, we would create a new concrete class that met the interface and the framework will inject it where that interface is declared."}),"\n",(0,i.jsx)(n.li,{children:"The ownership of the dependencies has moved from the class to something operating at much higher level."}),"\n",(0,i.jsxs)(n.li,{children:["This is termed an ",(0,i.jsx)(n.strong,{children:"Inversion of Control"})," and in this pattern in particular, ",(0,i.jsx)(n.strong,{children:"Dependency Injection"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"introducing-beans",children:"Introducing Beans"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Coding to interfaces instead of concrete classes is the way to do things and it's up to the framework to supply the concrete classes wherever we declare our interfaces via dependency injection."}),"\n",(0,i.jsxs)(n.li,{children:["The term ",(0,i.jsx)(n.strong,{children:"beans"})," refers to those concrete classes, that is the term that spring framework uses and by extension spring boot."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"configuration",children:"@Configuration"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Beans can be defined in a configuration class."}),"\n",(0,i.jsxs)(n.li,{children:["The annotation ",(0,i.jsx)(n.code,{children:"@Configuration"})," has to be added to the class to tell Spring to look into this class for bean definitions."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"bean",children:"@Bean"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"This annotation is used to indicate that a method instantiates, configures and initializes a new object to be managed by the Spring IoC container."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"@Configuration\npublic class PrinterConfig {\n  private RedPrinter redPrinter; // interface\n  private BluePrinter bluePrinter; // interface\n\n  @Bean\n  public RedPrinter redPrinter() {\n    return new EnglishRedPrinter();\n  }\n\n  @Bean\n  public BluePrinter bluePrinter() {\n    return new EnglishBluePrinter();\n  }\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>s});var i=t(7294);const r={},o=i.createContext(r);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);